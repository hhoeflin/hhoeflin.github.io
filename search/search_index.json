{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>My name in Holger Hoefling and I am a Statistician, Machine Learner and Bioinformatician. For the last 10 years I have worked for Novartis in various roles, currently as the Lead of the machine learning group in Data Science, NX, NIBR.</p> <p>In my career I have worked on a wide range of data science problems in the healthcare field. This experience spans from working on clinical study protocols, the development of predictive algorithms for kidney disease to the statistical analysis of experiments in early non-clinical research with microarray, NGS and other biomarker data.</p> <p>More recently I have been the leader of a team of machine learners working on applications in cheminformatics as well deep learning on histopathology images and other imaging applications.</p>"},{"location":"#blog-entries","title":"Blog entries","text":""},{"location":"#devtools-setup-using-make","title":"Devtools setup using make","text":"<p>Description of an simple, lightweight setup for installing development tools in a reproducible manner in the home-folder  without the use of sudo-rights.</p>"},{"location":"#nix-in-home-folder","title":"Nix in home folder","text":"<p>How to compile nix for use in a custom location on systems where the user doesn't have root is and user-namespaces are not available as well.</p>"},{"location":"#bash-in-docker","title":"Bash in docker","text":"<p>How to use bash inside docker, especially with repect to interactive as well as login shells.</p>"},{"location":"publications/","title":"Articles","text":"<ul> <li>Freyre CAC, Spiegel S, Gubser Keller C, Vandemeulebroecke M, Hoefling H, Dubost V, et al. Biomarker-Based Classification and Localization of Renal Lesions Using Learned Representations of Histology\u2014A Machine Learning Approach to Histopathology. Toxicol Pathol [Internet]. SAGE Publications Inc; 2021. Online</li> <li>Hoefling H*, Sing T*, Hossain I, Boisclair J, Doelemeyer A, Flandre T, et al. HistoNet: A Deep Learning-Based Model of Normal Histology. Toxicol Pathol [Internet]. SAGE Publications Inc; 2021. Online (* the authors contributed equally)</li> <li>Sing T*, Hoefling H*, Hossain I, Boisclair J, Doelemeyer A, Flandre T, et al. A deep learning-based model of normal histology. bioRxiv. 2019;838417. Online (* the authors contributed equally)</li> <li>Mueller A, Hoefling HA, Muaremi A, Praestgaard J, Walsh LC, Bunte O, et al. Continuous Digital Monitoring of Walking Speed in Frail Elderly Patients: Noninterventional Validation Study and Longitudinal Clinical Trial. JMIR mHealth and uHealth. 2019;7:e15191. Online</li> <li>Keppler AM, Nuritidinow T, Mueller A, Hoefling H, Schieker M, Clay I, et al. Validity of accelerometry in step detection and gait speed measurement in orthogeriatric patients. PLOS ONE. 2019;14:e0221732. Online</li> <li>Mueller A, Hoefling H, Nuritdinow T, Holway N, Schieker M, Daumer M, et al. Continuous Monitoring of Patient Mobility for 18 Months Using Inertial Sensors following Traumatic Knee Injury: A Case Study. Digital Biomarkers. 2018;79\u201389. Online</li> <li>Viallon V, Lambert-Lacroix S, H\u00f6fling H, Picard F. On the robustness of the generalized fused lasso to prior specifications. Stat Comput. 2016;26:285\u2013301. Online</li> <li>Hoe\ufb02ing H, Rossini A. Reproducible Research for large scale data analysis. Implementing Reproducible Research. New York: Chapman and Hall/CRC; 2014. p. 219\u201340.</li> <li>H\u00f6fling H, Eckert C, Schumacher M. \u201cClassification of Therapy Resistance Based on Longitudinal Biomarker Profiles\u201d by M. Kohlmann, L. Held and V. P. Grunert Biometrical Journal (2009) 51(4):610\u2013626 Article. Authors\u2019 reply. 2010;52:562\u20136. Online</li> <li>H\u00f6fling H, Binder H, Schumacher M. A coordinate-wise optimization algorithm for the Fused Lasso. 2010; Online</li> <li>Hoefling H. A Path Algorithm for the Fused Lasso Signal Approximator. Journal of Computational and Graphical Statistics. 2010;19:984\u20131006. Online</li> <li>H\u00f6fling H, Tibshirani R. Estimation of Sparse Binary Pairwise Markov Networks using Pseudo-likelihoods. J Mach Learn Res. 2009;10:883\u2013906. Online</li> <li>H\u00f6fling H, Wasserman L. Discussion of: \u201cStatistical analysis of an archeological find\u201d by Andrey Feuerverger. AOAS. 2008;2:77\u201383. Online</li> <li>Hofling and Wasserman - Discussion of Statistical analysis of an archeolo.pdf.</li> <li>H\u00f6fling H, Tibshirani R. A study of pre-validation. The Annals of Applied Statistics. 2008;2:643\u201364. Online</li> <li>Getz G, Hofling H, Mesirov JP, Golub TR, Meyerson M, Tibshirani R, et al. Comment on \u201cThe Consensus Coding Sequences of Human Breast and Colorectal Cancers.\u201d Science. 2007;317:1500\u20131500. Online</li> <li>Friedman J, Hastie T, H\u00f6fling H, Tibshirani R. Pathwise coordinate optimization. The Annals of Applied Statistics. 2007;1:302\u201332. Online</li> <li>H\u00f6fling H, Kiesel R, L\u00f6ffler G. Understanding the Corporate Bond Yield Curve. The Pension Forum. 2004;15:2\u201334.</li> </ul>"},{"location":"publications/#posters","title":"Posters","text":"<ul> <li>Sing T, Hossain I, H\u00f6fling H, Doelemeyer A, Saravanan C, Piaia A, et al. A deep learning-based model of normal histology. New York, USA; 2018. Presented at the Digital Pathology &amp; AI Congress, New York, USA, 2018.</li> </ul>"},{"location":"publications/#talks","title":"Talks","text":"<ul> <li>H\u00f6fling H. Machine Learning on pathology images. Hinxton, UK; 2018. Conference: EMBL-EBI workshop on \"Machine Learning in Drug Discovery and Precision Medicine\"</li> </ul>"},{"location":"blog/bash_in_docker/","title":"How to use bash in docker using configuration files","text":""},{"location":"blog/bash_in_docker/#abstract","title":"Abstract","text":"<p>When using Docker for data science, a particular problem is to ensure that the correct environments are loaded at all times, e.g. conda.</p> <p>In order to ensure that the environment is loaded correctly at all times, it has to be initalized when starting an interactive shell as well as when starting a program using a run command.</p> <p>In the following we will show that this can best be achieved in 2 ways: a) Always start each interactive shell and each run command using a login shell. b) For interactive shells define a bashrc-file and set the environemnt variable $BASH_ENV to the same file for non-interactive shells (e.g. run commands).</p>"},{"location":"blog/bash_in_docker/#type-of-shells","title":"Type of shells","text":"<p>Before we see all this in detail, we first review how the bash shell configuration works. For shells, there are two properties that each shell has. It is either a login or a non-login shell as well as an interactive or non-interactive shell.</p>"},{"location":"blog/bash_in_docker/#login-shells","title":"Login shells","text":"<p>A login shell is typically started when logging into a computer. In it, certain startup scripts are sourced that can be used to set the initial values for environment varialbles, e.g. PATH. A new bash shell can be explicitly turned into a login shell by using the -l or --login options.</p>"},{"location":"blog/bash_in_docker/#interactive-shells","title":"Interactive shells","text":"<p>An interactive shell is a shell that has its input, output and error streams connected to a terminal. This is typically the case when you start a shell inside another shell or when starting a shell in a docker container. The typical case of a non-interactive shell is a shell that is started in order to run a script. The option -i can be used to explicitly turn a shell into an interactive shell.</p> <p>In addition to these option there are other switches that can be used to customize the behaviour which startup scripts get run and we will go over them and their effects later.</p>"},{"location":"blog/bash_in_docker/#configuration-files","title":"Configuration files","text":"<p>There are a number of different configuration files that are sourced in different situations. Here an overview of the ones relevant for bash:</p> <ul> <li>/etc/profile: This system-wide script is sourced by     login-shells at startup before any other files are sourced</li> <li>/etc/profile.d: A system-wide directory from which additional     scripts are sourced by login shells. While not formally listed in     the GNU manual linked above, most distributions also read all     scripts in this directory.</li> <li>~/.bash_profile, ~/.bash_login, ~/.profile: These are scripts     for individual users that are read by login shells. Only the first     of these scripts that exists and is readable is used. If the option     --noprofile is used, none of these scripts is sourced.</li> <li>/etc/bashrc or /etc/bash.bashrc: A system-wide script that is     sourced by interactive shells. CentOS uses /etc/bashrc whereas     Debian-based systems use /etc/bash.bashrc.</li> <li>~/.bashrc: This user-specific script is sourced for all     interactive shells. If the option --norc is used, this file is     not being sourced. If the option --rcfile file is being used,     file is sourced instead of ~/.bashrc.</li> <li>$BASH_ENV: If a non-interactive shell is started and the     environment variable BASH_ENV exists, then the script file     referenced in BASH_ENV will be sourced.</li> </ul>"},{"location":"blog/bash_in_docker/#behaviour-for-sh","title":"Behaviour for sh","text":"<p>When bash is invoked with the name sh, then its behviour changes.</p> <ul> <li>login: This behviour occurs when sh is started with the     --login option. It sources /etc/profile and ~/.profile in this     order. The --noprofile prevents this (clarify if it prevents     reading of both files or only one of them).</li> <li>interactive: It looks for the environment variable ENV and     sources the file referenced here. The option --rcfile has no     effect.</li> <li>non-interactive:: No startup files are being sourced.</li> </ul>"},{"location":"blog/bash_in_docker/#posix-mode","title":"POSIX mode:","text":"<p>When started in POSIX mode, only the file referenced in the variable ENV is sourced. No other files are sourced.</p>"},{"location":"blog/bash_in_docker/#the-docker-setup","title":"The docker setup","text":"<p>The rules for when which configuration files are executed for which shell can be quite challenging to remember - at least for users that don't use this functionality every day. The setup becomes even more challenging when used together with Docker, where it is a priori less clear which type of shell is in use at which point.</p> <p>In order to make this easier to remember we create a small docker container that shows which configuration files are run in which order under different conditions.</p> <p>In the container, echo commands specifying the name of the file being sourced are either - added at the end of the configuration file - replace the configuration file with the echo command</p> <p>The reason for these two different conditions is that by default some configuration files by default source other files and with this setup we want to highlight the exact connections between files.</p>"},{"location":"blog/bash_in_docker/#bash-as-an-interactive-shell","title":"Bash as an interactive shell","text":"<p>We can of course also regularly start bash as an interactive shell in the docker container usign the -it option for the docker-run command. We also specify to docker to log us in as userA.</p> <p>In this case, /etc/bash.bashrc and /home/userA/.bashrc are being sourced (please note that it doesn't occur as an explicit code-block here as the interactive part does not work in a Jupyter notebook).</p> <pre><code>docker run -it --user userA hhoeflin/shell_test:bash-append /bin/bash\n\n## Source /etc/bash.bashrc\n## Source /home/userA/.bashrc\n## userA@55411b7d527f:/$ exit\n</code></pre> <p>Another option to start an interactive shell is the -i option to bash. This cannot be combined with the bash -c option to run a command passed as a string, but we can use it when executing a script. However this results in an error</p> <pre><code>docker run --user userA hhoeflin/shell_test:bash-append /bin/bash -i /home/userA/script.sh\n\n## bash: cannot set terminal process group (-1): Inappropriate ioctl for device\n## bash: no job control in this shell\n## Source /etc/bash.bashrc\n## Source /home/userA/.bashrc\n## /home/userA\n</code></pre> <p>In this case, instead of /etc/bash.bashrc and /home/userA/.bashrc, we can force a specific file to be used with the --rcfile option. We can also ensure that for interactive shells, no configuration script is loaded with --norc.</p>"},{"location":"blog/bash_in_docker/#the-non-interactive-bash-shell","title":"The non-interactive bash shell","text":"<p>Instead of the interactive shell, we however usually when running a container are being dropped into a non-interactive, non-login shell.</p> <pre><code>docker run hhoeflin/shell_test:bash-append /bin/bash\n</code></pre> <p>As we can see, this sources no files at all. But when we now set the BASH_ENV variable to /etc/profile, we see that the script gets loaded - together with the script file in /etc/profile.d.</p> <pre><code>docker run -e BASH_ENV=/etc/profile hhoeflin/shell_test:bash-append /bin/bash\n\n## Source /etc/profile.d/test.sh\n## Source /etc/profile\n</code></pre> <p>Strictly speaking the script in /etc/profile.d should not have been loaded - at least we did not explicitly ask for it. The reason is that all script in /etc/profile.d get sourced by the default /etc/profile. We confirm this by running the same command, but this time using the version of the configuration scripts that got replaced with the echo commands - not appended to.</p> <pre><code>docker run -e BASH_ENV=/etc/profile hhoeflin/shell_test:bash-replace /bin/bash\n\n## Source /etc/profile\n</code></pre>"},{"location":"blog/bash_in_docker/#bash-as-a-login-shell","title":"Bash as a login shell","text":"<p>When running bash, we can ask for it to be a login shell using the -l or --login option.</p> <pre><code>docker run hhoeflin/shell_test:bash-append /bin/bash --login\n\n## Source /etc/profile.d/test.sh\n## Source /etc/profile\n</code></pre> <p>and all the profile-related scripts get sourced. When at the same time we pass the --noprofile option</p> <pre><code>docker run hhoeflin/shell_test:bash-append /bin/bash --login --noprofile\n</code></pre> <p>it prevents any profile scripts from being loaded.</p> <p>Now this was all so far for the root user. We can also do this for any other user</p> <pre><code>docker run --user userA hhoeflin/shell_test:bash-append /bin/bash --login\n\n## Source /etc/profile.d/test.sh\n## Source /etc/profile\n## Source /home/userA/.bash_profile\n</code></pre> <p>in which case ~/.bash_profile gets loaded, as this is the first user-specific configuration file. For userB and userC, we can see similar results, just with their user-specific config files. For userD that has all 3 profile-configuration files, ony the first, ~/.bash_profile gets loaded.</p>"},{"location":"blog/bash_in_docker/#summary","title":"Summary","text":"<p>We have seen how to use login shell and interactive/non-interactive shells in a Docker container. If the goal is to have a specific script run in interactive shells and non-interactive shells executing a command, then there are basically 2 choices to make this happen.</p> <p>The first choice is to make interactive shells as well as non-interactive shells both login shells and put the script that should be executed into either /etc/profile.d if it should be run for all users or into ~/.profile if it is intended for a specific user. This however requires to set the -l option on all shells that are run.</p> <p>The second option is to set the script as /etc/bash.bashrc (or /etc/bashrc on CentOS). In this case, this will automatically be run for all interactive shells. For non-interactive shells, the BASH_ENV variable pointing to this file would ensure that it is sourced in this case as well.</p> <p>Overall, requiring users to always request a login shell and not include any bashrc files is overall a bit more consistent in my opinion.</p>"},{"location":"blog/bash_in_docker/#references","title":"References","text":"<p>In order to compile this Dockerfile and writeup I used various sources on the internet. - A good introduction to the subject is GNU - Bash Startup Files. - Another very nice post is Bash interactive, login shell types - Bash cheat sheet (thanks to Marc Wilson for the link).</p>"},{"location":"blog/bash_in_docker/#updates","title":"Updates","text":"<ul> <li>Added bash cheat-sheet on Dec 28th 2021 on suggestion of Marc Wilson.</li> </ul>"},{"location":"blog/devtools_with_make/","title":"Using makefiles and environment modules for tools in home folder","text":"<p>August 2023</p>"},{"location":"blog/devtools_with_make/#introduction","title":"Introduction","text":"<p>In a previous post in Nix in home folder I talked about how to set up  development tools in ones home-folder without root using the Nix package manager. While that affords very high reproducibility, it also required a large amount of maintenance as well as time for compiling the tools. For practical purposes, this turned out not to be feasible in the cases where needed most  -- i.e. when working on systems without root access.</p> <p>Therefore, looking for a simpler and more maintanable solution that also works well on shared HPC systems, I set up a repository that only uses <code>make</code> as well as <code>lmod</code> environment models together with standard build-tools such as wget, autotools and gcc. </p>"},{"location":"blog/devtools_with_make/#setup","title":"Setup","text":"<p>The setup can be seen in Makefiles. In here, the global <code>Makefile</code> just calls the makefiles included in the subdirectories, where each program has a subdirectory. This rule is only not true for applications that use <code>Rust</code> or <code>Golang</code> and are so standardized in their installation that a general makefile-recipe can be used with  minor adjustments using environment variables. </p> <p>When installing software, most applications follow relatively closely a standard recipe, but  occasionally some adjustments are necessary. In order to allow for this flexibility, I defined a set of standard variables and recipes, that are however easy to override  (see default.mk).</p> <p>In a typical application makefile, recipes for downloading the application source as well  as the compilation are defined, whereas recipes for <code>clean</code> or <code>uninstall</code> as well as  the creation of environment modules for use with <code>lmod</code> are usually the default. This setup overall makes it simple to install the application into a pre-defined directory hierarchy of  type /.  <p>For <code>Rust</code>-based apps, typically it is enough to use a single standard makefile that is  configured only using environment variables  (see rust_app). Similary I use application written in <code>Golang</code> with a single recipe. From this mechanism I deviate for things like <code>exa</code>, an <code>ls</code> replacement, as there additional aliases are defined in the <code>module_template</code> file and it therefore needs further customization that the simple recipe cannot define. </p> <p>The makefile also has the option to use certein environment modules that are provided by the platform (such as compilers) and those can be specified in the environment variable <code>GLOBAL_MODULES</code> where all modules that should be used can be listed (space separated). This can be seen at the  end of <code>default.mk</code>.</p>"},{"location":"blog/devtools_with_make/#summary","title":"Summary","text":"<p>Overall, this provides for a simple, lightweight setup that is  - easy to maintain - easy to debug - can use certain libraries or applications that are typically installed</p> <p>The added bonus is that it uses environment modules, so individual programs can quickly be loaded or unloaded and the modules can be set up to provide additional features such as aliases that  can be helpful (and then don't have to be specified in the <code>.bashrc</code>, where they would be useless when the application gets unloaded). </p>"},{"location":"blog/home_folder_nix/","title":"Nix and Home-manager in custom directory","text":"<p>February 2022</p>"},{"location":"blog/home_folder_nix/#introduction","title":"Introduction","text":"<p>A few months ago I was looking for a way to create a setup for tools and software in my home-folder that was easy and fast to deploy in a new location. After some searching, I discovered Nix and Home-Manager.</p> <p>From their wiki, NixOS is a Linux distribution based on the Nix package manager and build system. It supports reproducible and declarative system-wide configuration management as well as atomic upgrades and rollbacks, although it can additionally support imperative package and user management. In NixOS, all components of the distribution \u2014 including the kernel, installed packages and system configuration files \u2014 are built by Nix from pure functions called Nix expressions.</p> <p>Home-Manager complements the Nix package manager by providing a system to manage a users configuration for the home folder.</p> <p>These tools have a relatively steep learning curve, but after a few months using it I have to say that it is very worth the investment of time. Nix is a very principled way to approach software deployment and its ideas provide a fresh perspective on how reproducible configuration of software can be done that provides multiple versions at the same time.</p>"},{"location":"blog/home_folder_nix/#installation","title":"Installation","text":"<p>Nix is very easy to install and instructions are provided on the homepage. However this is only true under the assumption that the user has <code>sudo</code> permissions or an administrator performs certain setup steps. If these conditions are not met, deploying nix is a lot trickier. In the rest of the post I will outline how to deploy nix using home-manager in the home folder without sudo.</p> <p>The biggest drawback of the route I have chosen is that the Nix binary cache does not work, which can mean long compile times when deploying new software (long can mean 10+ hours). This can be tricky when trying to install software ad-hoc, but for me is an ok tradeoff for deploying home-folder software where the setup changes much more slowly. Additionally, not every program works without error when compiled from scratch so that ocassionally an override patch is necessary.</p>"},{"location":"blog/home_folder_nix/#nix-portable","title":"Nix-portable","text":"<p>Nix-portable is a wrapper that allows nix to be used in a users home folder without sudo permissions while still being able to use the binary cache. Please go the its website to read about some of the requirements and missing features of this approach.</p> <p>In my case, it does not support sufficient features to deploy a Home-Manager setup so that I decided not to use it.</p>"},{"location":"blog/home_folder_nix/#why-not-use-some-other-tool","title":"Why not use some other tool?","text":"<p>Before going into more details of the setup, I briefly wanted to talk about some of the other tools that could be used for similar purposes.</p>"},{"location":"blog/home_folder_nix/#homebrew","title":"Homebrew","text":"<p>Homebrew, often called the missing package manager for MacOS (and later also linux), is a tool to easily install software in a user's home directory. Its big advantage is that it can be run without sudo and that a very large amount of packages is available for installation.</p> <p>It is a very good tool, however it does not provide the same level of independence of the host system as Nix does, so incompatibilities from one OS to the other can happen. Furthermore, it also does not a manager for home-folder configurations such as Home-Manager</p>"},{"location":"blog/home_folder_nix/#spack-or-easybuild","title":"Spack or Easybuild","text":"<p>Both Spack and Easybuild are tools to install software on HPC systems. As such they have the ability to install multiple versions of the same software side by side and allow the user to activate them on-demand (e.g. by using environment modules).</p> <p>Both these systems are very sophisticated and are more targeted towards HPC admins than individual users. In general, availablility of packages and latest versions is lower than for Nix and they also don't provide a complete solution for managing the home-folder configurations.</p>"},{"location":"blog/home_folder_nix/#the-build-process","title":"The build process","text":"<p>Now let us move on to the actual installation process.</p>"},{"location":"blog/home_folder_nix/#requirements","title":"Requirements","text":"<p>It is necessary to have a linux distribution available with sudo permissions so that nix can be deployed as described in the user manual. In the following it is assumed that a nix installation is available with nix version &gt;= 2.4.</p>"},{"location":"blog/home_folder_nix/#setting-environment-variables","title":"Setting environment variables","text":"<p>In order to install in a custom location, it is possible to change the directories used by Nix with environment variables. These need to be sourced before the build process.</p> nix_vars.sh<pre><code>PREFIX=/home/testuser\nexport NIX_STORE_DIR=${PREFIX}/nix/store\nexport NIX_DATA_DIR=${PREFIX}/nix/share\nexport NIX_LOG_DIR=${PREFIX}/nix/var/log/nix\nexport NIX_STATE_DIR=${PREFIX}/nix/var/nix\nexport NIX_CONF_DIR=${PREFIX}/nix/etc/nix\nNIX_PROFILES=\"${NIX_STATE_DIR}/profiles/default ${PREFIX}/.nix-profile\"\n</code></pre> <p>This corresponds to a nix installation where <code>storedir=${PREFIX}/nix/store</code>, <code>localstatedir=${PREFIX}/nix/var/</code> and <code>sysconfdir=${PREFIX}/nix/etc</code>, where <code>storedir</code>, <code>localstatedir</code> and <code>sysconfdir</code> are defined in the nix installation in nixpkgs defined in nix/default.nix and the details for the environment variables in local.mk</p>"},{"location":"blog/home_folder_nix/#the-flake","title":"The flake","text":"<p>At first for practice we write a flake for only compiling nix itself. In this flake we need to override some attributes in order to set the custom variables as well as add some patches (on linux, the sandbox test is broken for non-default directories, so we disable it). A basic flake could be</p> flake.nix<pre><code>{\n  inputs = {\n    flake-utils.url = \"github:numtide/flake-utils\";\n  };\n  outputs = {self, nixpkgs, flake-utils}:\n    let\n      overlay-nix = final: prev:\n        let prefix = \"/home/testuser/nix\";\n        in\n        {\n          nix_prefix = (prev.nix.override {\n            storeDir = \"${prefix}/store\";\n            stateDir = \"${prefix}/var\";\n            confDir = \"${prefix}/etc\";\n          }).overrideAttrs (oldAttrs: rec {\n            patches = (oldAttrs.patches or []) ++ [./nix_patch_2_5.patch];\n          });\n        };\n    in\n    flake-utils.lib.eachDefaultSystem\n      (system:\n        let pkgs = import nixpkgs {overlays = [overlay-nix]; inherit system;}; in\n        {\n          packages.nix = pkgs.nix_prefix;\n        }\n      );\n}\n</code></pre> <p>with patch</p> nix_patch_2_5.patch<pre><code>diff --git a/tests/common.sh.in b/tests/common.sh.in\nindex 61abab1d7..3947db160 100644\n--- a/tests/common.sh.in\n+++ b/tests/common.sh.in\n@@ -119,10 +119,6 @@ restartDaemon() {\n   startDaemon\n }\n\n-if [[ $(uname) == Linux ]] &amp;&amp; [[ -L /proc/self/ns/user ]] &amp;&amp; unshare --user true; then\n-    _canUseSandbox=1\n-fi\n-\n isDaemonNewer () {\n   [[ -n \"${NIX_DAEMON_PACKAGE:-}\" ]] || return 0\n   local requiredVersion=\"$1\"\n</code></pre> <p>With this flake, we can just build a version of nix with <code>nix build .#nix</code>.</p>"},{"location":"blog/home_folder_nix/#flake-for-home-manager","title":"Flake for home-manager","text":"<p>We also want to use this in home-manager of course. A minimal flake to set this up is below, together with a minimal <code>home.nix</code> that just requires <code>nix</code> itself and ensures the environment  variables are loaded in the profile. As of this writing, the current version of nix was 2.5.1.</p> <p>flake.nix<pre><code>{\n  description = \"Home Manager NixOS configuration\";\n\n  inputs = {\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n  outputs = inputs@{ self, nixpkgs, home-manager, ... }:\n    {\n      homeConfigurations = {\n        testuser = inputs.home-manager.lib.homeManagerConfiguration {\n          system = \"x86_64-linux\";\n          # Home Manager needs a bit of information about you and the\n          # paths it should manage.\n          homeDirectory = \"/home/testuser\";\n          username = \"testuser\";\n          # This value determines the Home Manager release that your\n          # configuration is compatible with. This helps avoid breakage\n          # when a new Home Manager release introduces backwards\n          # incompatible changes.\n          # You can update Home Manager without changing this value. See\n          # the Home Manager release notes for a list of state version\n          # changes in each release.\n          stateVersion = \"21.11\";\n\n          configuration = { config, pkgs, ... }:\n            let\n              overlay-nix = final: prev:\n                let prefix = \"/home/testuser/nix\";\n                in\n            {\n                  nix_2_3 = (prev.nix_2_3.override {\n                    storeDir = \"${prefix}/store\";\n                    stateDir = \"${prefix}/var\";\n                    confDir = \"${prefix}/etc\";\n                  }).overrideAttrs (oldAttrs: rec {\n                    patches = (oldAttrs.patches or []) ++ [./nix_patch_2_3.patch];\n                  });\n                  nix = (prev.nix.override {\n                    storeDir = \"${prefix}/store\";\n                    stateDir = \"${prefix}/var\";\n                    confDir = \"${prefix}/etc\";\n                  }).overrideAttrs (oldAttrs: rec {\n                    patches = (oldAttrs.patches or []) ++ [./nix_patch_2_5.patch];\n                  });\n              };\n            in\n            {\n              nixpkgs.overlays = [ overlay-nix];\n              nixpkgs.config = {\n                allowUnfree = true;\n                allowBroken = true;\n              };\n\n              imports = [\n                ./home.nix\n              ];\n\n            };\n        };\n      };\n      testuser = self.homeConfigurations.testuser.activationPackage;\n      defaultPackage.x86_64-linux = self.testuser;\n    };\n}\n</code></pre> As home-manager depends on nix-2.3, we also create a patch that disables sandbox testing for that version.</p> nix_patch_2_3.patch<pre><code>diff --git a/tests/common.sh.in b/tests/common.sh.in\nindex 15d7b1ef9..9e2242ac4 100644\n--- a/tests/common.sh.in\n+++ b/tests/common.sh.in\n@@ -86,10 +86,6 @@ killDaemon() {\n     trap \"\" EXIT\n }\n\n-if [[ $(uname) == Linux ]] &amp;&amp; [[ -L /proc/self/ns/user ]] &amp;&amp; unshare --user true; then\n-    _canUseSandbox=1\n-fi\n-\n canUseSandbox() {\n     if [[ ! $_canUseSandbox ]]; then\n         echo \"Sandboxing not supported, skipping this test...\"\n</code></pre> <p>For defining the home-folder environment itself, we need a <code>home.nix</code> file that we import in the configuration. This one is quite minimal, defining <code>nix</code> itself as the only read dependency. We also set the <code>profile</code> for the account so that all scripts in <code>profile.d</code> directory in the home-folder are being read, where we then set the script to read the environment variables.</p> home.nix<pre><code>{ config, pkgs, ... }:\n\n{\n  # Let Home Manager install and manage itself.\n  programs.home-manager.enable = true;\n\n  home.packages = with pkgs; [\n    # we want nix itself to be installed by home-manager\n    nix\n\n  ];\n\n  programs.bash = {\n    enable = true;\n    profileExtra = ''\n      . $HOME/.nix-profile/etc/profile.d/nix.sh\n\n      if [ -d $HOME/profile.d ]; then\n        for i in $HOME/profile.d/*.sh; do\n          if [ -r $i ]; then\n            . $i\n          fi\n        done\n        unset i\n      fi\n\n\n    '';\n  };\n  # load the nix-vars to configure correctly\n  home.file.\"profile.d/nix_vars.sh\".source = ./nix_vars.sh;\n\n}\n</code></pre> <p>As to having nix in home-manager itself, it is not necessary and up to the end user. Having it in there automatically upgrades nix on new deployments, and builds it in one go when building home-manager but it also makes initial deployment trickier, as the first time nix itself has to be uninstalled from the user environment.</p> <p>Typical steps for installing this new would be:</p> <pre><code># set the PATH explicitly to the installed nix\nexport PATH=$(dirname $(readlink $(which nix))):$PATH\n\n# we remove nix itself that comes pre-installed from the user profile\nnix-env -e nix\n\n# build the flake for the testuser\nnix build .#testuser\n\n# run the activate script\n./result/activate\n</code></pre>"},{"location":"blog/home_folder_nix/#discussion","title":"Discussion","text":"<p>In the setup before, even after compiling nix with a different state and store directory, we still have to load the environment variables for it to work reliably. The reason is that home-manager used incorrect directories e.g. for lock files if they were not set. Setting the environment variables fixed the issue, but I did not track down which particular variable is necessary.</p> <p>Another observation is that compilation of nix and libraries works very well, up to minor issues like the error in the sandbox tests of nix. I am not sure if this is due to the OS where I compiled it (Ubuntu) or due to the custom nix-store paths.</p> <p>I had also trouble confirming the new store and state-paths were correctly picked up by nix. Commands like <code>nix show-config</code> for example don't list any of these directories, making it hard to confirm what they are using (but probably, as I am still very new to this, I don't know how to do this correctly).</p> <p>I hope this was helpful, but please let me know in the comments below.</p>"},{"location":"blog/home_folder_nix/#other-resources","title":"Other resources","text":"<p>My starting point was a Github repository that compiles nix for HPC at danielbarter/hpc-nix.</p>"}]}