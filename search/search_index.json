{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction My name in Holger Hoefling and I am a Statistician, Machine Learner and Bioinformatician. For the last 10 years I have worked for Novartis in various roles, currently as the Lead of the machine learning group in Data Science, NX, NIBR. In my career I have worked on a wide range of data science problems in the healthcare field. This experience spans from working on clinical study protocols, the development of predictive algorithms for kidney disease to the statistical analysis of experiments in early non-clinical research with microarray, NGS and other biomarker data. More recently I have been the leader of a team of machine learners working on applications in cheminformatics as well deep learning on histopathology images and other imaging applications. Blog entries Nix in home folder How to compile nix for use in a custom location on systems where the user doesn't have root is and user-namespaces are not available as well. Bash in docker How to use bash inside docker, especially with repect to interactive as well as login shells.","title":"Home"},{"location":"#introduction","text":"My name in Holger Hoefling and I am a Statistician, Machine Learner and Bioinformatician. For the last 10 years I have worked for Novartis in various roles, currently as the Lead of the machine learning group in Data Science, NX, NIBR. In my career I have worked on a wide range of data science problems in the healthcare field. This experience spans from working on clinical study protocols, the development of predictive algorithms for kidney disease to the statistical analysis of experiments in early non-clinical research with microarray, NGS and other biomarker data. More recently I have been the leader of a team of machine learners working on applications in cheminformatics as well deep learning on histopathology images and other imaging applications.","title":"Introduction"},{"location":"#blog-entries","text":"","title":"Blog entries"},{"location":"#nix-in-home-folder","text":"How to compile nix for use in a custom location on systems where the user doesn't have root is and user-namespaces are not available as well.","title":"Nix in home folder"},{"location":"#bash-in-docker","text":"How to use bash inside docker, especially with repect to interactive as well as login shells.","title":"Bash in docker"},{"location":"publications/","text":"Articles Freyre CAC, Spiegel S, Gubser Keller C, Vandemeulebroecke M, Hoefling H, Dubost V, et al. Biomarker-Based Classification and Localization of Renal Lesions Using Learned Representations of Histology\u2014A Machine Learning Approach to Histopathology. Toxicol Pathol [Internet]. SAGE Publications Inc; 2021. Online Hoefling H*, Sing T*, Hossain I, Boisclair J, Doelemeyer A, Flandre T, et al. HistoNet: A Deep Learning-Based Model of Normal Histology. Toxicol Pathol [Internet]. SAGE Publications Inc; 2021. Online (* the authors contributed equally) Sing T*, Hoefling H*, Hossain I, Boisclair J, Doelemeyer A, Flandre T, et al. A deep learning-based model of normal histology. bioRxiv. 2019;838417. Online (* the authors contributed equally) Mueller A, Hoefling HA, Muaremi A, Praestgaard J, Walsh LC, Bunte O, et al. Continuous Digital Monitoring of Walking Speed in Frail Elderly Patients: Noninterventional Validation Study and Longitudinal Clinical Trial. JMIR mHealth and uHealth. 2019;7:e15191. Online Keppler AM, Nuritidinow T, Mueller A, Hoefling H, Schieker M, Clay I, et al. Validity of accelerometry in step detection and gait speed measurement in orthogeriatric patients. PLOS ONE. 2019;14:e0221732. Online Mueller A, Hoefling H, Nuritdinow T, Holway N, Schieker M, Daumer M, et al. Continuous Monitoring of Patient Mobility for 18 Months Using Inertial Sensors following Traumatic Knee Injury: A Case Study. Digital Biomarkers. 2018;79\u201389. Online Viallon V, Lambert-Lacroix S, H\u00f6fling H, Picard F. On the robustness of the generalized fused lasso to prior specifications. Stat Comput. 2016;26:285\u2013301. Online Hoe\ufb02ing H, Rossini A. Reproducible Research for large scale data analysis. Implementing Reproducible Research. New York: Chapman and Hall/CRC; 2014. p. 219\u201340. H\u00f6fling H, Eckert C, Schumacher M. \u201cClassification of Therapy Resistance Based on Longitudinal Biomarker Profiles\u201d by M. Kohlmann, L. Held and V. P. Grunert Biometrical Journal (2009) 51(4):610\u2013626 Article . Authors\u2019 reply . 2010;52:562\u20136. Online H\u00f6fling H, Binder H, Schumacher M. A coordinate-wise optimization algorithm for the Fused Lasso. 2010; Online Hoefling H. A Path Algorithm for the Fused Lasso Signal Approximator. Journal of Computational and Graphical Statistics. 2010;19:984\u20131006. Online H\u00f6fling H, Tibshirani R. Estimation of Sparse Binary Pairwise Markov Networks using Pseudo-likelihoods. J Mach Learn Res. 2009;10:883\u2013906. Online H\u00f6fling H, Wasserman L. Discussion of: \u201cStatistical analysis of an archeological find\u201d by Andrey Feuerverger. AOAS. 2008;2:77\u201383. Online Hofling and Wasserman - Discussion of Statistical analysis of an archeolo.pdf. H\u00f6fling H, Tibshirani R. A study of pre-validation. The Annals of Applied Statistics. 2008;2:643\u201364. Online Getz G, Hofling H, Mesirov JP, Golub TR, Meyerson M, Tibshirani R, et al. Comment on \u201cThe Consensus Coding Sequences of Human Breast and Colorectal Cancers.\u201d Science. 2007;317:1500\u20131500. Online Friedman J, Hastie T, H\u00f6fling H, Tibshirani R. Pathwise coordinate optimization. The Annals of Applied Statistics. 2007;1:302\u201332. Online H\u00f6fling H, Kiesel R, L\u00f6ffler G. Understanding the Corporate Bond Yield Curve. The Pension Forum. 2004;15:2\u201334. Posters Sing T, Hossain I, H\u00f6fling H, Doelemeyer A, Saravanan C, Piaia A, et al. A deep learning-based model of normal histology. New York, USA; 2018. Presented at the Digital Pathology & AI Congress, New York, USA, 2018. Talks H\u00f6fling H. Machine Learning on pathology images. Hinxton, UK; 2018. Conference: EMBL-EBI workshop on \"Machine Learning in Drug Discovery and Precision Medicine\"","title":"Publications"},{"location":"publications/#articles","text":"Freyre CAC, Spiegel S, Gubser Keller C, Vandemeulebroecke M, Hoefling H, Dubost V, et al. Biomarker-Based Classification and Localization of Renal Lesions Using Learned Representations of Histology\u2014A Machine Learning Approach to Histopathology. Toxicol Pathol [Internet]. SAGE Publications Inc; 2021. Online Hoefling H*, Sing T*, Hossain I, Boisclair J, Doelemeyer A, Flandre T, et al. HistoNet: A Deep Learning-Based Model of Normal Histology. Toxicol Pathol [Internet]. SAGE Publications Inc; 2021. Online (* the authors contributed equally) Sing T*, Hoefling H*, Hossain I, Boisclair J, Doelemeyer A, Flandre T, et al. A deep learning-based model of normal histology. bioRxiv. 2019;838417. Online (* the authors contributed equally) Mueller A, Hoefling HA, Muaremi A, Praestgaard J, Walsh LC, Bunte O, et al. Continuous Digital Monitoring of Walking Speed in Frail Elderly Patients: Noninterventional Validation Study and Longitudinal Clinical Trial. JMIR mHealth and uHealth. 2019;7:e15191. Online Keppler AM, Nuritidinow T, Mueller A, Hoefling H, Schieker M, Clay I, et al. Validity of accelerometry in step detection and gait speed measurement in orthogeriatric patients. PLOS ONE. 2019;14:e0221732. Online Mueller A, Hoefling H, Nuritdinow T, Holway N, Schieker M, Daumer M, et al. Continuous Monitoring of Patient Mobility for 18 Months Using Inertial Sensors following Traumatic Knee Injury: A Case Study. Digital Biomarkers. 2018;79\u201389. Online Viallon V, Lambert-Lacroix S, H\u00f6fling H, Picard F. On the robustness of the generalized fused lasso to prior specifications. Stat Comput. 2016;26:285\u2013301. Online Hoe\ufb02ing H, Rossini A. Reproducible Research for large scale data analysis. Implementing Reproducible Research. New York: Chapman and Hall/CRC; 2014. p. 219\u201340. H\u00f6fling H, Eckert C, Schumacher M. \u201cClassification of Therapy Resistance Based on Longitudinal Biomarker Profiles\u201d by M. Kohlmann, L. Held and V. P. Grunert Biometrical Journal (2009) 51(4):610\u2013626 Article . Authors\u2019 reply . 2010;52:562\u20136. Online H\u00f6fling H, Binder H, Schumacher M. A coordinate-wise optimization algorithm for the Fused Lasso. 2010; Online Hoefling H. A Path Algorithm for the Fused Lasso Signal Approximator. Journal of Computational and Graphical Statistics. 2010;19:984\u20131006. Online H\u00f6fling H, Tibshirani R. Estimation of Sparse Binary Pairwise Markov Networks using Pseudo-likelihoods. J Mach Learn Res. 2009;10:883\u2013906. Online H\u00f6fling H, Wasserman L. Discussion of: \u201cStatistical analysis of an archeological find\u201d by Andrey Feuerverger. AOAS. 2008;2:77\u201383. Online Hofling and Wasserman - Discussion of Statistical analysis of an archeolo.pdf. H\u00f6fling H, Tibshirani R. A study of pre-validation. The Annals of Applied Statistics. 2008;2:643\u201364. Online Getz G, Hofling H, Mesirov JP, Golub TR, Meyerson M, Tibshirani R, et al. Comment on \u201cThe Consensus Coding Sequences of Human Breast and Colorectal Cancers.\u201d Science. 2007;317:1500\u20131500. Online Friedman J, Hastie T, H\u00f6fling H, Tibshirani R. Pathwise coordinate optimization. The Annals of Applied Statistics. 2007;1:302\u201332. Online H\u00f6fling H, Kiesel R, L\u00f6ffler G. Understanding the Corporate Bond Yield Curve. The Pension Forum. 2004;15:2\u201334.","title":"Articles"},{"location":"publications/#posters","text":"Sing T, Hossain I, H\u00f6fling H, Doelemeyer A, Saravanan C, Piaia A, et al. A deep learning-based model of normal histology. New York, USA; 2018. Presented at the Digital Pathology & AI Congress, New York, USA, 2018.","title":"Posters"},{"location":"publications/#talks","text":"H\u00f6fling H. Machine Learning on pathology images. Hinxton, UK; 2018. Conference: EMBL-EBI workshop on \"Machine Learning in Drug Discovery and Precision Medicine\"","title":"Talks"},{"location":"docker/bash_in_docker/","text":"How to use bash in docker using configuration files Abstract When using Docker for data science, a particular problem is to ensure that the correct environments are loaded at all times, e.g. conda. In order to ensure that the environment is loaded correctly at all times, it has to be initalized when starting an interactive shell as well as when starting a program using a run command. In the following we will show that this can best be achieved in 2 ways: a) Always start each interactive shell and each run command using a login shell. b) For interactive shells define a bashrc-file and set the environemnt variable $BASH_ENV to the same file for non-interactive shells (e.g. run commands). Type of shells Before we see all this in detail, we first review how the bash shell configuration works. For shells, there are two properties that each shell has. It is either a login or a non-login shell as well as an interactive or non-interactive shell. Login shells A login shell is typically started when logging into a computer. In it, certain startup scripts are sourced that can be used to set the initial values for environment varialbles, e.g. PATH. A new bash shell can be explicitly turned into a login shell by using the -l or --login options. Interactive shells An interactive shell is a shell that has its input, output and error streams connected to a terminal. This is typically the case when you start a shell inside another shell or when starting a shell in a docker container. The typical case of a non-interactive shell is a shell that is started in order to run a script. The option -i can be used to explicitly turn a shell into an interactive shell. In addition to these option there are other switches that can be used to customize the behaviour which startup scripts get run and we will go over them and their effects later. Configuration files There are a number of different configuration files that are sourced in different situations. Here an overview of the ones relevant for bash: /etc/profile: This system-wide script is sourced by login -shells at startup before any other files are sourced /etc/profile.d: A system-wide directory from which additional scripts are sourced by login shells. While not formally listed in the GNU manual linked above, most distributions also read all scripts in this directory. ~/.bash_profile, ~/.bash_login, ~/.profile: These are scripts for individual users that are read by login shells. Only the first of these scripts that exists and is readable is used. If the option --noprofile is used, none of these scripts is sourced. /etc/bashrc or /etc/bash.bashrc: A system-wide script that is sourced by interactive shells. CentOS uses /etc/bashrc whereas Debian-based systems use /etc/bash.bashrc . ~/.bashrc: This user-specific script is sourced for all interactive shells. If the option --norc is used, this file is not being sourced. If the option --rcfile file is being used, file is sourced instead of ~/.bashrc . $BASH_ENV: If a non-interactive shell is started and the environment variable BASH_ENV exists, then the script file referenced in BASH_ENV will be sourced. Behaviour for sh When bash is invoked with the name sh , then its behviour changes. login: This behviour occurs when sh is started with the --login option. It sources /etc/profile and ~/.profile in this order. The --noprofile prevents this (clarify if it prevents reading of both files or only one of them). interactive: It looks for the environment variable ENV and sources the file referenced here. The option --rcfile has no effect. non-interactive: : No startup files are being sourced. POSIX mode: When started in POSIX mode, only the file referenced in the variable ENV is sourced. No other files are sourced. The docker setup The rules for when which configuration files are executed for which shell can be quite challenging to remember - at least for users that don't use this functionality every day. The setup becomes even more challenging when used together with Docker, where it is a priori less clear which type of shell is in use at which point. In order to make this easier to remember we create a small docker container that shows which configuration files are run in which order under different conditions. In the container, echo commands specifying the name of the file being sourced are either - added at the end of the configuration file - replace the configuration file with the echo command The reason for these two different conditions is that by default some configuration files by default source other files and with this setup we want to highlight the exact connections between files. Bash as an interactive shell We can of course also regularly start bash as an interactive shell in the docker container usign the -it option for the docker-run command. We also specify to docker to log us in as userA . In this case, /etc/bash.bashrc and /home/userA/.bashrc are being sourced (please note that it doesn't occur as an explicit code-block here as the interactive part does not work in a Jupyter notebook). docker run -it --user userA hhoeflin/shell_test:bash-append /bin/bash ## Source /etc/bash.bashrc ## Source /home/userA/.bashrc ## userA@55411b7d527f:/$ exit Another option to start an interactive shell is the -i option to bash. This cannot be combined with the bash -c option to run a command passed as a string, but we can use it when executing a script. However this results in an error docker run --user userA hhoeflin/shell_test:bash-append /bin/bash -i /home/userA/script.sh ## bash: cannot set terminal process group (-1): Inappropriate ioctl for device ## bash: no job control in this shell ## Source /etc/bash.bashrc ## Source /home/userA/.bashrc ## /home/userA In this case, instead of /etc/bash.bashrc and /home/userA/.bashrc , we can force a specific file to be used with the --rcfile option. We can also ensure that for interactive shells, no configuration script is loaded with --norc . The non-interactive bash shell Instead of the interactive shell, we however usually when running a container are being dropped into a non-interactive, non-login shell. docker run hhoeflin/shell_test:bash-append /bin/bash As we can see, this sources no files at all. But when we now set the BASH_ENV variable to /etc/profile , we see that the script gets loaded - together with the script file in /etc/profile.d . docker run -e BASH_ENV=/etc/profile hhoeflin/shell_test:bash-append /bin/bash ## Source /etc/profile.d/test.sh ## Source /etc/profile Strictly speaking the script in /etc/profile.d should not have been loaded - at least we did not explicitly ask for it. The reason is that all script in /etc/profile.d get sourced by the default /etc/profile . We confirm this by running the same command, but this time using the version of the configuration scripts that got replaced with the echo commands - not appended to. docker run -e BASH_ENV=/etc/profile hhoeflin/shell_test:bash-replace /bin/bash ## Source /etc/profile Bash as a login shell When running bash, we can ask for it to be a login shell using the -l or --login option. docker run hhoeflin/shell_test:bash-append /bin/bash --login ## Source /etc/profile.d/test.sh ## Source /etc/profile and all the profile-related scripts get sourced. When at the same time we pass the --noprofile option docker run hhoeflin/shell_test:bash-append /bin/bash --login --noprofile it prevents any profile scripts from being loaded. Now this was all so far for the root user. We can also do this for any other user docker run --user userA hhoeflin/shell_test:bash-append /bin/bash --login ## Source /etc/profile.d/test.sh ## Source /etc/profile ## Source /home/userA/.bash_profile in which case ~/.bash_profile gets loaded, as this is the first user-specific configuration file. For userB and userC , we can see similar results, just with their user-specific config files. For userD that has all 3 profile-configuration files, ony the first, ~/.bash_profile gets loaded. Summary We have seen how to use login shell and interactive/non-interactive shells in a Docker container. If the goal is to have a specific script run in interactive shells and non-interactive shells executing a command, then there are basically 2 choices to make this happen. The first choice is to make interactive shells as well as non-interactive shells both login shells and put the script that should be executed into either /etc/profile.d if it should be run for all users or into ~/.profile if it is intended for a specific user. This however requires to set the -l option on all shells that are run. The second option is to set the script as /etc/bash.bashrc (or /etc/bashrc on CentOS). In this case, this will automatically be run for all interactive shells. For non-interactive shells, the BASH_ENV variable pointing to this file would ensure that it is sourced in this case as well. Overall, requiring users to always request a login shell and not include any bashrc files is overall a bit more consistent in my opinion. References In order to compile this Dockerfile and writeup I used various sources on the internet. - A good introduction to the subject is GNU - Bash Startup Files . - Another very nice post is Bash interactive, login shell types - Bash cheat sheet (thanks to Marc Wilson for the link). Updates Added bash cheat-sheet on Dec 28th 2021 on suggestion of Marc Wilson.","title":"Bash in Docker"},{"location":"docker/bash_in_docker/#how-to-use-bash-in-docker-using-configuration-files","text":"","title":"How to use bash in docker using configuration files"},{"location":"docker/bash_in_docker/#abstract","text":"When using Docker for data science, a particular problem is to ensure that the correct environments are loaded at all times, e.g. conda. In order to ensure that the environment is loaded correctly at all times, it has to be initalized when starting an interactive shell as well as when starting a program using a run command. In the following we will show that this can best be achieved in 2 ways: a) Always start each interactive shell and each run command using a login shell. b) For interactive shells define a bashrc-file and set the environemnt variable $BASH_ENV to the same file for non-interactive shells (e.g. run commands).","title":"Abstract"},{"location":"docker/bash_in_docker/#type-of-shells","text":"Before we see all this in detail, we first review how the bash shell configuration works. For shells, there are two properties that each shell has. It is either a login or a non-login shell as well as an interactive or non-interactive shell.","title":"Type of shells"},{"location":"docker/bash_in_docker/#login-shells","text":"A login shell is typically started when logging into a computer. In it, certain startup scripts are sourced that can be used to set the initial values for environment varialbles, e.g. PATH. A new bash shell can be explicitly turned into a login shell by using the -l or --login options.","title":"Login shells"},{"location":"docker/bash_in_docker/#interactive-shells","text":"An interactive shell is a shell that has its input, output and error streams connected to a terminal. This is typically the case when you start a shell inside another shell or when starting a shell in a docker container. The typical case of a non-interactive shell is a shell that is started in order to run a script. The option -i can be used to explicitly turn a shell into an interactive shell. In addition to these option there are other switches that can be used to customize the behaviour which startup scripts get run and we will go over them and their effects later.","title":"Interactive shells"},{"location":"docker/bash_in_docker/#configuration-files","text":"There are a number of different configuration files that are sourced in different situations. Here an overview of the ones relevant for bash: /etc/profile: This system-wide script is sourced by login -shells at startup before any other files are sourced /etc/profile.d: A system-wide directory from which additional scripts are sourced by login shells. While not formally listed in the GNU manual linked above, most distributions also read all scripts in this directory. ~/.bash_profile, ~/.bash_login, ~/.profile: These are scripts for individual users that are read by login shells. Only the first of these scripts that exists and is readable is used. If the option --noprofile is used, none of these scripts is sourced. /etc/bashrc or /etc/bash.bashrc: A system-wide script that is sourced by interactive shells. CentOS uses /etc/bashrc whereas Debian-based systems use /etc/bash.bashrc . ~/.bashrc: This user-specific script is sourced for all interactive shells. If the option --norc is used, this file is not being sourced. If the option --rcfile file is being used, file is sourced instead of ~/.bashrc . $BASH_ENV: If a non-interactive shell is started and the environment variable BASH_ENV exists, then the script file referenced in BASH_ENV will be sourced.","title":"Configuration files"},{"location":"docker/bash_in_docker/#behaviour-for-sh","text":"When bash is invoked with the name sh , then its behviour changes. login: This behviour occurs when sh is started with the --login option. It sources /etc/profile and ~/.profile in this order. The --noprofile prevents this (clarify if it prevents reading of both files or only one of them). interactive: It looks for the environment variable ENV and sources the file referenced here. The option --rcfile has no effect. non-interactive: : No startup files are being sourced.","title":"Behaviour for sh"},{"location":"docker/bash_in_docker/#posix-mode","text":"When started in POSIX mode, only the file referenced in the variable ENV is sourced. No other files are sourced.","title":"POSIX mode:"},{"location":"docker/bash_in_docker/#the-docker-setup","text":"The rules for when which configuration files are executed for which shell can be quite challenging to remember - at least for users that don't use this functionality every day. The setup becomes even more challenging when used together with Docker, where it is a priori less clear which type of shell is in use at which point. In order to make this easier to remember we create a small docker container that shows which configuration files are run in which order under different conditions. In the container, echo commands specifying the name of the file being sourced are either - added at the end of the configuration file - replace the configuration file with the echo command The reason for these two different conditions is that by default some configuration files by default source other files and with this setup we want to highlight the exact connections between files.","title":"The docker setup"},{"location":"docker/bash_in_docker/#bash-as-an-interactive-shell","text":"We can of course also regularly start bash as an interactive shell in the docker container usign the -it option for the docker-run command. We also specify to docker to log us in as userA . In this case, /etc/bash.bashrc and /home/userA/.bashrc are being sourced (please note that it doesn't occur as an explicit code-block here as the interactive part does not work in a Jupyter notebook). docker run -it --user userA hhoeflin/shell_test:bash-append /bin/bash ## Source /etc/bash.bashrc ## Source /home/userA/.bashrc ## userA@55411b7d527f:/$ exit Another option to start an interactive shell is the -i option to bash. This cannot be combined with the bash -c option to run a command passed as a string, but we can use it when executing a script. However this results in an error docker run --user userA hhoeflin/shell_test:bash-append /bin/bash -i /home/userA/script.sh ## bash: cannot set terminal process group (-1): Inappropriate ioctl for device ## bash: no job control in this shell ## Source /etc/bash.bashrc ## Source /home/userA/.bashrc ## /home/userA In this case, instead of /etc/bash.bashrc and /home/userA/.bashrc , we can force a specific file to be used with the --rcfile option. We can also ensure that for interactive shells, no configuration script is loaded with --norc .","title":"Bash as an interactive shell"},{"location":"docker/bash_in_docker/#the-non-interactive-bash-shell","text":"Instead of the interactive shell, we however usually when running a container are being dropped into a non-interactive, non-login shell. docker run hhoeflin/shell_test:bash-append /bin/bash As we can see, this sources no files at all. But when we now set the BASH_ENV variable to /etc/profile , we see that the script gets loaded - together with the script file in /etc/profile.d . docker run -e BASH_ENV=/etc/profile hhoeflin/shell_test:bash-append /bin/bash ## Source /etc/profile.d/test.sh ## Source /etc/profile Strictly speaking the script in /etc/profile.d should not have been loaded - at least we did not explicitly ask for it. The reason is that all script in /etc/profile.d get sourced by the default /etc/profile . We confirm this by running the same command, but this time using the version of the configuration scripts that got replaced with the echo commands - not appended to. docker run -e BASH_ENV=/etc/profile hhoeflin/shell_test:bash-replace /bin/bash ## Source /etc/profile","title":"The non-interactive bash shell"},{"location":"docker/bash_in_docker/#bash-as-a-login-shell","text":"When running bash, we can ask for it to be a login shell using the -l or --login option. docker run hhoeflin/shell_test:bash-append /bin/bash --login ## Source /etc/profile.d/test.sh ## Source /etc/profile and all the profile-related scripts get sourced. When at the same time we pass the --noprofile option docker run hhoeflin/shell_test:bash-append /bin/bash --login --noprofile it prevents any profile scripts from being loaded. Now this was all so far for the root user. We can also do this for any other user docker run --user userA hhoeflin/shell_test:bash-append /bin/bash --login ## Source /etc/profile.d/test.sh ## Source /etc/profile ## Source /home/userA/.bash_profile in which case ~/.bash_profile gets loaded, as this is the first user-specific configuration file. For userB and userC , we can see similar results, just with their user-specific config files. For userD that has all 3 profile-configuration files, ony the first, ~/.bash_profile gets loaded.","title":"Bash as a login shell"},{"location":"docker/bash_in_docker/#summary","text":"We have seen how to use login shell and interactive/non-interactive shells in a Docker container. If the goal is to have a specific script run in interactive shells and non-interactive shells executing a command, then there are basically 2 choices to make this happen. The first choice is to make interactive shells as well as non-interactive shells both login shells and put the script that should be executed into either /etc/profile.d if it should be run for all users or into ~/.profile if it is intended for a specific user. This however requires to set the -l option on all shells that are run. The second option is to set the script as /etc/bash.bashrc (or /etc/bashrc on CentOS). In this case, this will automatically be run for all interactive shells. For non-interactive shells, the BASH_ENV variable pointing to this file would ensure that it is sourced in this case as well. Overall, requiring users to always request a login shell and not include any bashrc files is overall a bit more consistent in my opinion.","title":"Summary"},{"location":"docker/bash_in_docker/#references","text":"In order to compile this Dockerfile and writeup I used various sources on the internet. - A good introduction to the subject is GNU - Bash Startup Files . - Another very nice post is Bash interactive, login shell types - Bash cheat sheet (thanks to Marc Wilson for the link).","title":"References"},{"location":"docker/bash_in_docker/#updates","text":"Added bash cheat-sheet on Dec 28th 2021 on suggestion of Marc Wilson.","title":"Updates"},{"location":"nix/home_folder_nix/","text":"Nix and Home-manager in custom directory Introduction A few months ago I was looking for a way to create a setup for tools and software in my home-folder that was easy and fast to deploy in a new location. After some searching, I discovered Nix and Home-Manager . From their wiki , NixOS is a Linux distribution based on the Nix package manager and build system. It supports reproducible and declarative system-wide configuration management as well as atomic upgrades and rollbacks, although it can additionally support imperative package and user management. In NixOS, all components of the distribution \u2014 including the kernel, installed packages and system configuration files \u2014 are built by Nix from pure functions called Nix expressions. Home-Manager complements the Nix package manager by providing a system to manage a users configuration for the home folder. These tools have a relatively steep learning curve, but after a few months using it I have to say that it is very worth the investment of time. Nix is a very principled way to approach software deployment and its ideas provide a fresh perspective on how reproducible configuration of software can be done that provides multiple versions at the same time. Installation Nix is very easy to install and instructions are provided on the homepage. However this is only true under the assumption that the user has sudo permissions or an administrator performs certain setup steps. If these conditions are not met, deploying nix is a lot trickier. In the rest of the post I will outline how to deploy nix using home-manager in the home folder without sudo. The biggest drawback of the route I have chosen is that the Nix binary cache does not work, which can mean long compile times when deploying new software (long can mean 10+ hours). This can be tricky when trying to install software ad-hoc, but for me is an ok tradeoff for deploying home-folder software where the setup changes much more slowly. Additionally, not every program works without error when compiled from scratch so that ocassionally an override patch is necessary. Nix-portable Nix-portable is a wrapper that allows nix to be used in a users home folder without sudo permissions while still being able to use the binary cache. Please go the its website to read about some of the requirements and missing features of this approach. In my case, it does not support sufficient features to deploy a Home-Manager setup so that I decided not to use it. Why not use some other tool? Before going into more details of the setup, I briefly wanted to talk about some of the other tools that could be used for similar purposes. Homebrew Homebrew , often called the missing package manager for MacOS (and later also linux), is a tool to easily install software in a user's home directory. Its big advantage is that it can be run without sudo and that a very large amount of packages is available for installation. It is a very good tool, however it does not provide the same level of independence of the host system as Nix does, so incompatibilities from one OS to the other can happen. Furthermore, it also does not a manager for home-folder configurations such as Home-Manager Spack or Easybuild Both Spack and Easybuild are tools to install software on HPC systems. As such they have the ability to install multiple versions of the same software side by side and allow the user to activate them on-demand (e.g. by using environment modules). Both these systems are very sophisticated and are more targeted towards HPC admins than individual users. In general, availablility of packages and latest versions is lower than for Nix and they also don't provide a complete solution for managing the home-folder configurations. The build process Now let us move on to the actual installation process. Requirements It is necessary to have a linux distribution available with sudo permissions so that nix can be deployed as described in the user manual. In the following it is assumed that a nix installation is available with nix version >= 2.4. Setting environment variables In order to install in a custom location, it is possible to change the directories used by Nix with environment variables. These need to be sourced before the build process. nix_vars.sh PREFIX=/home/testuser export NIX_STORE_DIR=${PREFIX}/nix/store export NIX_DATA_DIR=${PREFIX}/nix/share export NIX_LOG_DIR=${PREFIX}/nix/var/log/nix export NIX_STATE_DIR=${PREFIX}/nix/var/nix export NIX_CONF_DIR=${PREFIX}/nix/etc/nix NIX_PROFILES=\"${NIX_STATE_DIR}/profiles/default ${PREFIX}/.nix-profile\" This corresponds to a nix installation where storedir=${PREFIX}/nix/store , localstatedir=${PREFIX}/nix/var/ and sysconfdir=${PREFIX}/nix/etc , where storedir , localstatedir and sysconfdir are defined in the nix installation in nixpkgs defined in nix/default.nix and the details for the environment variables in local.mk The flake At first for practice we write a flake for only compiling nix itself. In this flake we need to override some attributes in order to set the custom variables as well as add some patches (on linux, the sandbox test is broken for non-default directories, so we disable it). A basic flake could be flake.nix { inputs = { flake-utils . url = \"github:numtide/flake-utils\" ; }; outputs = { self , nixpkgs , flake-utils }: let overlay-nix = final : prev : let prefix = \"/home/testuser/nix\" ; in { nix_prefix = ( prev . nix . override { storeDir = \" ${ prefix } /store\" ; stateDir = \" ${ prefix } /var\" ; confDir = \" ${ prefix } /etc\" ; }) . overrideAttrs ( oldAttrs : rec { patches = ( oldAttrs . patches or []) ++ [ . /nix_patch_2_5.patch ]; }); }; in flake-utils . lib . eachDefaultSystem ( system : let pkgs = import nixpkgs { overlays = [ overlay-nix ]; inherit system ;}; in { packages . nix = pkgs . nix_prefix ; } ); } with patch nix_patch_2_5.patch diff --git a/tests/common.sh.in b/tests/common.sh.in index 61abab1d7..3947db160 100644 --- a/tests/common.sh.in +++ b/tests/common.sh.in @@ -119,10 +119,6 @@ restartDaemon() { startDaemon } -if [[ $(uname) == Linux ]] && [[ -L /proc/self/ns/user ]] && unshare --user true; then - _canUseSandbox=1 -fi - isDaemonNewer () { [[ -n \"${NIX_DAEMON_PACKAGE:-}\" ]] || return 0 local requiredVersion=\"$1\" With this flake, we can just build a version of nix with nix build .#nix . Flake for home-manager We also want to use this in home-manager of course. A minimal flake to set this up is below, together with a minimal home.nix that just requires nix itself and ensures the environment variables are loaded in the profile. As of this writing, the current version of nix was 2.5.1. flake.nix { description = \"Home Manager NixOS configuration\"; inputs = { home-manager.url = \"github:nix-community/home-manager\"; home-manager.inputs.nixpkgs.follows = \"nixpkgs\"; }; outputs = inputs@{ self, nixpkgs, home-manager, ... }: { homeConfigurations = { testuser = inputs.home-manager.lib.homeManagerConfiguration { system = \"x86_64-linux\"; # Home Manager needs a bit of information about you and the # paths it should manage. homeDirectory = \"/home/testuser\"; username = \"testuser\"; # This value determines the Home Manager release that your # configuration is compatible with. This helps avoid breakage # when a new Home Manager release introduces backwards # incompatible changes. # You can update Home Manager without changing this value. See # the Home Manager release notes for a list of state version # changes in each release. stateVersion = \"21.11\"; configuration = { config, pkgs, ... }: let overlay-nix = final: prev: let prefix = \"/home/testuser/nix\"; in { nix_2_3 = (prev.nix_2_3.override { storeDir = \"${prefix}/store\"; stateDir = \"${prefix}/var\"; confDir = \"${prefix}/etc\"; }).overrideAttrs (oldAttrs: rec { patches = (oldAttrs.patches or []) ++ [./nix_patch_2_3.patch]; }); nix = (prev.nix.override { storeDir = \"${prefix}/store\"; stateDir = \"${prefix}/var\"; confDir = \"${prefix}/etc\"; }).overrideAttrs (oldAttrs: rec { patches = (oldAttrs.patches or []) ++ [./nix_patch_2_5.patch]; }); }; in { nixpkgs.overlays = [ overlay-nix]; nixpkgs.config = { allowUnfree = true; allowBroken = true; }; imports = [ ./home.nix ]; }; }; }; testuser = self.homeConfigurations.testuser.activationPackage; defaultPackage.x86_64-linux = self.testuser; }; } As home-manager depends on nix-2.3, we also create a patch that disables sandbox testing for that version. nix_patch_2_3.patch diff --git a/tests/common.sh.in b/tests/common.sh.in index 15d7b1ef9..9e2242ac4 100644 --- a/tests/common.sh.in +++ b/tests/common.sh.in @@ -86,10 +86,6 @@ killDaemon() { trap \"\" EXIT } -if [[ $(uname) == Linux ]] && [[ -L /proc/self/ns/user ]] && unshare --user true; then - _canUseSandbox=1 -fi - canUseSandbox() { if [[ ! $_canUseSandbox ]]; then echo \"Sandboxing not supported, skipping this test...\" For defining the home-folder environment itself, we need a home.nix file that we import in the configuration. This one is quite minimal, defining nix itself as the only read dependency. We also set the profile for the account so that all scripts in profile.d directory in the home-folder are being read, where we then set the script to read the environment variables. home.nix { config, pkgs, ... }: { # Let Home Manager install and manage itself. programs.home-manager.enable = true; home.packages = with pkgs; [ # we want nix itself to be installed by home-manager nix ]; programs.bash = { enable = true; profileExtra = '' . $HOME/.nix-profile/etc/profile.d/nix.sh if [ -d $HOME/profile.d ]; then for i in $HOME/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset i fi ''; }; # load the nix-vars to configure correctly home.file.\"profile.d/nix_vars.sh\".source = ./nix_vars.sh; } As to having nix in home-manager itself, it is not necessary and up to the end user. Having it in there automatically upgrades nix on new deployments, and builds it in one go when building home-manager but it also makes initial deployment trickier, as the first time nix itself has to be uninstalled from the user environment. Typical steps for installing this new would be: # set the PATH explicitly to the installed nix export PATH = $( dirname $( readlink $( which nix ))) : $PATH # we remove nix itself that comes pre-installed from the user profile nix-env -e nix # build the flake for the testuser nix build .#testuser # run the activate script ./result/activate Discussion In the setup before, even after compiling nix with a different state and store directory, we still have to load the environment variables for it to work reliably. The reason is that home-manager used incorrect directories e.g. for lock files if they were not set. Setting the environment variables fixed the issue, but I did not track down which particular variable is necessary. Another observation is that compilation of nix and libraries works very well, up to minor issues like the error in the sandbox tests of nix. I am not sure if this is due to the OS where I compiled it (Ubuntu) or due to the custom nix-store paths. I had also trouble confirming the new store and state-paths were correctly picked up by nix. Commands like nix show-config for example don't list any of these directories, making it hard to confirm what they are using (but probably, as I am still very new to this, I don't know how to do this correctly). I hope this was helpful, but please let me know in the comments below. Other resources My starting point was a Github repository that compiles nix for HPC at danielbarter/hpc-nix .","title":"Nix in home"},{"location":"nix/home_folder_nix/#nix-and-home-manager-in-custom-directory","text":"","title":"Nix and Home-manager in custom directory"},{"location":"nix/home_folder_nix/#introduction","text":"A few months ago I was looking for a way to create a setup for tools and software in my home-folder that was easy and fast to deploy in a new location. After some searching, I discovered Nix and Home-Manager . From their wiki , NixOS is a Linux distribution based on the Nix package manager and build system. It supports reproducible and declarative system-wide configuration management as well as atomic upgrades and rollbacks, although it can additionally support imperative package and user management. In NixOS, all components of the distribution \u2014 including the kernel, installed packages and system configuration files \u2014 are built by Nix from pure functions called Nix expressions. Home-Manager complements the Nix package manager by providing a system to manage a users configuration for the home folder. These tools have a relatively steep learning curve, but after a few months using it I have to say that it is very worth the investment of time. Nix is a very principled way to approach software deployment and its ideas provide a fresh perspective on how reproducible configuration of software can be done that provides multiple versions at the same time.","title":"Introduction"},{"location":"nix/home_folder_nix/#installation","text":"Nix is very easy to install and instructions are provided on the homepage. However this is only true under the assumption that the user has sudo permissions or an administrator performs certain setup steps. If these conditions are not met, deploying nix is a lot trickier. In the rest of the post I will outline how to deploy nix using home-manager in the home folder without sudo. The biggest drawback of the route I have chosen is that the Nix binary cache does not work, which can mean long compile times when deploying new software (long can mean 10+ hours). This can be tricky when trying to install software ad-hoc, but for me is an ok tradeoff for deploying home-folder software where the setup changes much more slowly. Additionally, not every program works without error when compiled from scratch so that ocassionally an override patch is necessary.","title":"Installation"},{"location":"nix/home_folder_nix/#nix-portable","text":"Nix-portable is a wrapper that allows nix to be used in a users home folder without sudo permissions while still being able to use the binary cache. Please go the its website to read about some of the requirements and missing features of this approach. In my case, it does not support sufficient features to deploy a Home-Manager setup so that I decided not to use it.","title":"Nix-portable"},{"location":"nix/home_folder_nix/#why-not-use-some-other-tool","text":"Before going into more details of the setup, I briefly wanted to talk about some of the other tools that could be used for similar purposes.","title":"Why not use some other tool?"},{"location":"nix/home_folder_nix/#homebrew","text":"Homebrew , often called the missing package manager for MacOS (and later also linux), is a tool to easily install software in a user's home directory. Its big advantage is that it can be run without sudo and that a very large amount of packages is available for installation. It is a very good tool, however it does not provide the same level of independence of the host system as Nix does, so incompatibilities from one OS to the other can happen. Furthermore, it also does not a manager for home-folder configurations such as Home-Manager","title":"Homebrew"},{"location":"nix/home_folder_nix/#spack-or-easybuild","text":"Both Spack and Easybuild are tools to install software on HPC systems. As such they have the ability to install multiple versions of the same software side by side and allow the user to activate them on-demand (e.g. by using environment modules). Both these systems are very sophisticated and are more targeted towards HPC admins than individual users. In general, availablility of packages and latest versions is lower than for Nix and they also don't provide a complete solution for managing the home-folder configurations.","title":"Spack or Easybuild"},{"location":"nix/home_folder_nix/#the-build-process","text":"Now let us move on to the actual installation process.","title":"The build process"},{"location":"nix/home_folder_nix/#requirements","text":"It is necessary to have a linux distribution available with sudo permissions so that nix can be deployed as described in the user manual. In the following it is assumed that a nix installation is available with nix version >= 2.4.","title":"Requirements"},{"location":"nix/home_folder_nix/#setting-environment-variables","text":"In order to install in a custom location, it is possible to change the directories used by Nix with environment variables. These need to be sourced before the build process. nix_vars.sh PREFIX=/home/testuser export NIX_STORE_DIR=${PREFIX}/nix/store export NIX_DATA_DIR=${PREFIX}/nix/share export NIX_LOG_DIR=${PREFIX}/nix/var/log/nix export NIX_STATE_DIR=${PREFIX}/nix/var/nix export NIX_CONF_DIR=${PREFIX}/nix/etc/nix NIX_PROFILES=\"${NIX_STATE_DIR}/profiles/default ${PREFIX}/.nix-profile\" This corresponds to a nix installation where storedir=${PREFIX}/nix/store , localstatedir=${PREFIX}/nix/var/ and sysconfdir=${PREFIX}/nix/etc , where storedir , localstatedir and sysconfdir are defined in the nix installation in nixpkgs defined in nix/default.nix and the details for the environment variables in local.mk","title":"Setting environment variables"},{"location":"nix/home_folder_nix/#the-flake","text":"At first for practice we write a flake for only compiling nix itself. In this flake we need to override some attributes in order to set the custom variables as well as add some patches (on linux, the sandbox test is broken for non-default directories, so we disable it). A basic flake could be flake.nix { inputs = { flake-utils . url = \"github:numtide/flake-utils\" ; }; outputs = { self , nixpkgs , flake-utils }: let overlay-nix = final : prev : let prefix = \"/home/testuser/nix\" ; in { nix_prefix = ( prev . nix . override { storeDir = \" ${ prefix } /store\" ; stateDir = \" ${ prefix } /var\" ; confDir = \" ${ prefix } /etc\" ; }) . overrideAttrs ( oldAttrs : rec { patches = ( oldAttrs . patches or []) ++ [ . /nix_patch_2_5.patch ]; }); }; in flake-utils . lib . eachDefaultSystem ( system : let pkgs = import nixpkgs { overlays = [ overlay-nix ]; inherit system ;}; in { packages . nix = pkgs . nix_prefix ; } ); } with patch nix_patch_2_5.patch diff --git a/tests/common.sh.in b/tests/common.sh.in index 61abab1d7..3947db160 100644 --- a/tests/common.sh.in +++ b/tests/common.sh.in @@ -119,10 +119,6 @@ restartDaemon() { startDaemon } -if [[ $(uname) == Linux ]] && [[ -L /proc/self/ns/user ]] && unshare --user true; then - _canUseSandbox=1 -fi - isDaemonNewer () { [[ -n \"${NIX_DAEMON_PACKAGE:-}\" ]] || return 0 local requiredVersion=\"$1\" With this flake, we can just build a version of nix with nix build .#nix .","title":"The flake"},{"location":"nix/home_folder_nix/#flake-for-home-manager","text":"We also want to use this in home-manager of course. A minimal flake to set this up is below, together with a minimal home.nix that just requires nix itself and ensures the environment variables are loaded in the profile. As of this writing, the current version of nix was 2.5.1. flake.nix { description = \"Home Manager NixOS configuration\"; inputs = { home-manager.url = \"github:nix-community/home-manager\"; home-manager.inputs.nixpkgs.follows = \"nixpkgs\"; }; outputs = inputs@{ self, nixpkgs, home-manager, ... }: { homeConfigurations = { testuser = inputs.home-manager.lib.homeManagerConfiguration { system = \"x86_64-linux\"; # Home Manager needs a bit of information about you and the # paths it should manage. homeDirectory = \"/home/testuser\"; username = \"testuser\"; # This value determines the Home Manager release that your # configuration is compatible with. This helps avoid breakage # when a new Home Manager release introduces backwards # incompatible changes. # You can update Home Manager without changing this value. See # the Home Manager release notes for a list of state version # changes in each release. stateVersion = \"21.11\"; configuration = { config, pkgs, ... }: let overlay-nix = final: prev: let prefix = \"/home/testuser/nix\"; in { nix_2_3 = (prev.nix_2_3.override { storeDir = \"${prefix}/store\"; stateDir = \"${prefix}/var\"; confDir = \"${prefix}/etc\"; }).overrideAttrs (oldAttrs: rec { patches = (oldAttrs.patches or []) ++ [./nix_patch_2_3.patch]; }); nix = (prev.nix.override { storeDir = \"${prefix}/store\"; stateDir = \"${prefix}/var\"; confDir = \"${prefix}/etc\"; }).overrideAttrs (oldAttrs: rec { patches = (oldAttrs.patches or []) ++ [./nix_patch_2_5.patch]; }); }; in { nixpkgs.overlays = [ overlay-nix]; nixpkgs.config = { allowUnfree = true; allowBroken = true; }; imports = [ ./home.nix ]; }; }; }; testuser = self.homeConfigurations.testuser.activationPackage; defaultPackage.x86_64-linux = self.testuser; }; } As home-manager depends on nix-2.3, we also create a patch that disables sandbox testing for that version. nix_patch_2_3.patch diff --git a/tests/common.sh.in b/tests/common.sh.in index 15d7b1ef9..9e2242ac4 100644 --- a/tests/common.sh.in +++ b/tests/common.sh.in @@ -86,10 +86,6 @@ killDaemon() { trap \"\" EXIT } -if [[ $(uname) == Linux ]] && [[ -L /proc/self/ns/user ]] && unshare --user true; then - _canUseSandbox=1 -fi - canUseSandbox() { if [[ ! $_canUseSandbox ]]; then echo \"Sandboxing not supported, skipping this test...\" For defining the home-folder environment itself, we need a home.nix file that we import in the configuration. This one is quite minimal, defining nix itself as the only read dependency. We also set the profile for the account so that all scripts in profile.d directory in the home-folder are being read, where we then set the script to read the environment variables. home.nix { config, pkgs, ... }: { # Let Home Manager install and manage itself. programs.home-manager.enable = true; home.packages = with pkgs; [ # we want nix itself to be installed by home-manager nix ]; programs.bash = { enable = true; profileExtra = '' . $HOME/.nix-profile/etc/profile.d/nix.sh if [ -d $HOME/profile.d ]; then for i in $HOME/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset i fi ''; }; # load the nix-vars to configure correctly home.file.\"profile.d/nix_vars.sh\".source = ./nix_vars.sh; } As to having nix in home-manager itself, it is not necessary and up to the end user. Having it in there automatically upgrades nix on new deployments, and builds it in one go when building home-manager but it also makes initial deployment trickier, as the first time nix itself has to be uninstalled from the user environment. Typical steps for installing this new would be: # set the PATH explicitly to the installed nix export PATH = $( dirname $( readlink $( which nix ))) : $PATH # we remove nix itself that comes pre-installed from the user profile nix-env -e nix # build the flake for the testuser nix build .#testuser # run the activate script ./result/activate","title":"Flake for home-manager"},{"location":"nix/home_folder_nix/#discussion","text":"In the setup before, even after compiling nix with a different state and store directory, we still have to load the environment variables for it to work reliably. The reason is that home-manager used incorrect directories e.g. for lock files if they were not set. Setting the environment variables fixed the issue, but I did not track down which particular variable is necessary. Another observation is that compilation of nix and libraries works very well, up to minor issues like the error in the sandbox tests of nix. I am not sure if this is due to the OS where I compiled it (Ubuntu) or due to the custom nix-store paths. I had also trouble confirming the new store and state-paths were correctly picked up by nix. Commands like nix show-config for example don't list any of these directories, making it hard to confirm what they are using (but probably, as I am still very new to this, I don't know how to do this correctly). I hope this was helpful, but please let me know in the comments below.","title":"Discussion"},{"location":"nix/home_folder_nix/#other-resources","text":"My starting point was a Github repository that compiles nix for HPC at danielbarter/hpc-nix .","title":"Other resources"}]}